{"version":3,"sources":["common/mapUtils.ts"],"names":[],"mappings":"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","file":"common/mapUtils.js","sourcesContent":["\n\nexport class CesiumMapUtils {\n\n    static getCameraFocus(map: Cesium.Viewer, inWorldCoordinates: boolean): Cesium.Cartesian3 {\n\n        let unprojectedScratch: Cesium.Cartographic = new Cesium.Cartographic();\n        let rayScratch: Cesium.Ray = new Cesium.Ray();\n\n        let scene: Cesium.Scene = map.scene;\n        let camera: Cesium.Camera = scene.camera;\n\n        if (scene.mode === Cesium.SceneMode.MORPHING) {\n            return undefined;\n        }\n\n        let result: Cesium.Cartesian3 = new Cesium.Cartesian3();\n\n        // TODO bug when tracking: if entity moves the current position should be used and not only the one when starting orbiting/rotating\n        // TODO bug when tracking: reset should reset to default view of tracked entity\n\n        if (map.trackedEntity) {\n            result = map.trackedEntity.position.getValue(map.clock.currentTime);\n        } else {\n            rayScratch.origin = camera.positionWC;\n            rayScratch.direction = camera.directionWC;\n            result = scene.globe.pick(rayScratch, scene, result);\n        }\n\n        if (!result) {\n            return undefined;\n        }\n\n        if (scene.mode === Cesium.SceneMode.SCENE2D || scene.mode === Cesium.SceneMode.COLUMBUS_VIEW) {\n            result = camera.worldToCameraCoordinatesPoint(result, result);\n\n            if (inWorldCoordinates) {\n                result = scene.globe.ellipsoid.cartographicToCartesian(scene.mapProjection.unproject(result, unprojectedScratch), result);\n            }\n        } else {\n            if (!inWorldCoordinates) {\n                result = camera.worldToCameraCoordinatesPoint(result, result);\n            }\n        }\n\n        return result;\n    }\n\n    static zoom(map: Cesium.Viewer, zoomIn: boolean): void {\n\n        let relativeAmount: number = 1.2;\n        let cartesian3Scratch: Cesium.Cartesian3 = new Cesium.Cartesian3();\n\n        if (zoomIn) {\n            // this ensures that zooming in is the inverse of zooming out and vice versa\n            // e.g. the camera position remains when zooming in and out\n            relativeAmount = 1 / relativeAmount;\n        }\n\n        if (map) {\n            let scene: Cesium.Scene = map.scene;\n\n            let camera: Cesium.Camera = scene.camera;\n            let orientation: any;\n\n            switch (scene.mode) {\n                case Cesium.SceneMode.MORPHING:\n                    break;\n                case Cesium.SceneMode.SCENE2D:\n                    camera.zoomIn(camera.positionCartographic.height * (1 - relativeAmount));\n                    break;\n                default:\n                    let focus: Cesium.Cartesian3;\n\n                    if (map.trackedEntity) {\n                        focus = new Cesium.Cartesian3();\n                    } else {\n                        focus = CesiumMapUtils.getCameraFocus(map, false);\n                    }\n\n                    if (focus) {\n                        // Camera direction is not pointing at the globe, so use the ellipsoid horizon point as\n                        // the focal point.\n                        let ray: Cesium.Ray = new Cesium.Ray(camera.worldToCameraCoordinatesPoint(scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic)), camera.directionWC);\n                        focus = Cesium.IntersectionTests.grazingAltitudeLocation(ray, scene.globe.ellipsoid);\n\n                        orientation = {\n                            heading: camera.heading,\n                            pitch: camera.pitch,\n                            roll: camera.roll\n                        };\n                    } else {\n                        orientation = {\n                            direction: camera.direction,\n                            up: camera.up\n                        };\n                    }\n\n                    let direction: Cesium.Cartesian3 = Cesium.Cartesian3.subtract(camera.position, focus, cartesian3Scratch);\n                    let movementVector: Cesium.Cartesian3 = Cesium.Cartesian3.multiplyByScalar(direction, relativeAmount, direction);\n                    let endPosition: Cesium.Cartesian3 = Cesium.Cartesian3.add(focus, movementVector, focus);\n\n                    if (map.trackedEntity || scene.mode === Cesium.SceneMode.COLUMBUS_VIEW) {\n                        // sometimes flyTo does not work (jumps to wrong position) so just set the position without any animation\n                        // do not use flyTo when tracking an entity because during animatiuon the position of the entity may change\n                        camera.position = endPosition;\n                    } else {\n                        camera.flyTo({\n                            destination: endPosition,\n                            orientation: orientation,\n                            duration: 0.5,\n                            convert: false\n                        });\n                    }\n            }\n        }\n    }\n\n}\n"],"sourceRoot":"/source/"}