"use strict";
var DSError_1 = require('@dronesense/core/lib/common/DSError');
var IClientInfo_1 = require('./IClientInfo');
var ServerNodeClient = (function () {
    function ServerNodeClient(clientInfo, ns) {
        var _this = this;
        this._socket = null;
        this.onConnected = null;
        this.onDisconnected = null;
        this.onConnectError = null;
        this._eventHandlers = {
            onConnect: function () {
                if (_this.onConnected !== null) {
                    _this.onConnected(_this);
                }
                if (_this._connectResolve) {
                    _this._connectResolve();
                }
            },
            onDisconnect: function (reason) {
                _this._socket.off('connect', _this._eventHandlers.onConnect);
                _this._socket.off('disconnect', _this._eventHandlers.onDisconnect);
                _this._socket.off('connect_error', _this._eventHandlers.onConnectError);
                _this._socket.off('error', _this._eventHandlers.onError);
                if (_this.onDisconnected !== null) {
                    _this.onDisconnected(_this);
                }
                if (_this._disconnectResolve) {
                    _this._disconnectResolve();
                }
            },
            onConnectError: function (error) {
                if (_this.onConnectError !== null) {
                    _this.onConnectError(_this, error);
                }
                if (_this._connectReject) {
                    _this._connectReject(DSError_1.DSError.create(DSError_1.DSError.Codes.CONNECT_FAILED, 'an error occurred while connecting', error));
                }
            },
            onError: function (error) {
                _this._eventHandlers.onConnectError(error);
                _this._socket.off('connect', _this._eventHandlers.onConnect);
                _this._socket.off('disconnect', _this._eventHandlers.onDisconnect);
                _this._socket.off('connect_error', _this._eventHandlers.onConnectError);
                _this._socket.off('error', _this._eventHandlers.onError);
            }
        };
        this._clientInfo = clientInfo;
        this._nsString = ns;
        this._children = new Array();
    }
    ServerNodeClient.prototype.on = function (event, fn) {
        this._socket.on(event, fn);
        return this;
    };
    ServerNodeClient.prototype.off = function (event, fn) {
        this._socket.off(event, fn);
        return this;
    };
    Object.defineProperty(ServerNodeClient.prototype, "ClientInfo", {
        get: function () {
            return this._clientInfo;
        },
        enumerable: true,
        configurable: true
    });
    ServerNodeClient.prototype.getConnectionString = function (excludeHostAddress) {
        if (!this._parent && excludeHostAddress) {
            return '';
        }
        if (!this._parent) {
            return !!this._nsString ? this._clientInfo.Address + this._nsString : this._clientInfo.Address;
        }
        else {
            return this._parent.getConnectionString(excludeHostAddress) + this._nsString;
        }
    };
    Object.defineProperty(ServerNodeClient.prototype, "Parent", {
        get: function () {
            return this._parent;
        },
        set: function (value) {
            this._parent = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServerNodeClient.prototype, "Children", {
        get: function () {
            return this._children;
        },
        enumerable: true,
        configurable: true
    });
    ServerNodeClient.create = function (address) {
        return new ServerNodeClient(new IClientInfo_1.ClientInfo(address));
    };
    ServerNodeClient.prototype.spawn = function (ns) {
        var childNode = new ServerNodeClient(this._clientInfo, ns);
        childNode._parent = this;
        this._children.push(childNode);
        if (this.Connected) {
            childNode.connect();
        }
        return childNode;
    };
    ServerNodeClient.prototype.release = function () {
        if (this.Parent) {
            var idx = this.Parent.Children.indexOf(this);
            if (idx >= 0) {
                this.Parent.Children.splice(idx, 1);
            }
            this.Parent.Children.splice(this.Parent.Children.indexOf(this), 1);
            this.Parent = null;
        }
        if (this.Connected) {
            this.disconnect();
        }
    };
    Object.defineProperty(ServerNodeClient.prototype, "Connected", {
        get: function () {
            return !!this._socket && this._socket.connected;
        },
        enumerable: true,
        configurable: true
    });
    ServerNodeClient.prototype.connect = function (username) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.Connected) {
                return reject(DSError_1.DSError.create(DSError_1.DSError.Codes.CONNECT_FAILED, 'Already connected.'));
            }
            _this._connectResolve = resolve;
            _this._connectReject = reject;
            console.log('Connecting to: ' + _this.getConnectionString(false));
            if (!_this._parent) {
                if (!username) {
                    throw new Error('a username is required to connect to a root node.');
                }
                _this._clientInfo.Username = username;
                _this._socket = io(_this.getConnectionString(false), {
                    query: 'username=' + username,
                    reconnection: false
                });
            }
            else {
                _this._socket = _this._parent._socket.io.socket(_this.getConnectionString(true));
            }
            _this._socket.on('connect', _this._eventHandlers.onConnect);
            _this._socket.on('disconnect', _this._eventHandlers.onDisconnect);
            _this._socket.on('connect_error', _this._eventHandlers.onConnectError);
            _this._socket.on('error', _this._eventHandlers.onError);
        }).then(function () {
            _this._connectReject = null;
            _this._connectResolve = null;
            return Promise.all(_this._children.map(function (child) {
                return child.connect();
            })).then(function () {
                return;
            });
        }).catch(function (error) {
            _this._connectReject = null;
            _this._connectResolve = null;
            throw error;
        });
    };
    ServerNodeClient.prototype.disconnect = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (!_this._socket.connected) {
                resolve();
            }
            else {
                _this._disconnectResolve = resolve;
                return Promise.all(_this._children.map(function (child) {
                    return child.disconnect();
                })).then(function () {
                    console.log('Disconnecting from: ' + _this.getConnectionString(false));
                    _this._socket.disconnect();
                });
            }
        }).then(function () {
            _this._disconnectResolve = null;
        });
    };
    ServerNodeClient.prototype.emit = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this._socket.emit.apply(this._socket, arguments);
        return this;
    };
    return ServerNodeClient;
}());
exports.ServerNodeClient = ServerNodeClient;

//# sourceMappingURL=IServerNodeClient.js.map
