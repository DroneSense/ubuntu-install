"use strict";
var BackboneEvents = require('backbone-events-standalone');
var Serializer_1 = require('@dronesense/core/lib/utility/Serializer');
var DSError_1 = require('@dronesense/core/lib/common/DSError');
var Events_1 = require('@dronesense/core/lib/common/Events');
var AWAIT_CONNECTION_TIMEOUT = 1000;
var ServerNodeClientController = (function () {
    function ServerNodeClientController(serverNodeClient) {
        var _this = this;
        this._awaitTimeoutId = null;
        this._awaitResolve = null;
        this.__eventHandlers = {
            propertyChanged: function (name, value) {
                _this._properties[name] = value;
                _this._onPropertyChanged(name, value);
            }
        };
        this._properties = {};
        if (serverNodeClient) {
            this._setServerNodeClient(serverNodeClient);
        }
    }
    ServerNodeClientController.prototype._setServerNodeClient = function (serverNodeClient) {
        var _this = this;
        this._serverNodeClient = serverNodeClient;
        this._serverNodeClient.onConnected = function (socket) {
            _this.Node.on(Events_1.Events.PROPERTY_CHANGED, _this.__eventHandlers.propertyChanged);
            _this.sendCommand(Events_1.Commands.REFRESH_PROPERTIES);
            if (_this._awaitResolve !== null) {
                _this._awaitResolve();
            }
            _this._onConnected(socket);
        };
        this._serverNodeClient.onDisconnected = function (socket) {
            _this.Node.off(Events_1.Events.PROPERTY_CHANGED, _this.__eventHandlers.propertyChanged);
            _this._onDisconnected(socket);
        };
        this._serverNodeClient.onConnectError = this._onConnectError.bind(this);
    };
    Object.defineProperty(ServerNodeClientController.prototype, "Node", {
        get: function () {
            return this._serverNodeClient;
        },
        enumerable: true,
        configurable: true
    });
    ServerNodeClientController.prototype._onConnected = function (socket) {
    };
    ServerNodeClientController.prototype._onDisconnected = function (socket) {
    };
    ServerNodeClientController.prototype._onConnectError = function (socket, error) {
    };
    ServerNodeClientController.prototype._onPropertyChanged = function (name, value) {
    };
    ServerNodeClientController.prototype._sendEvent = function (event, args) {
        var _this = this;
        return this._awaitConnection(AWAIT_CONNECTION_TIMEOUT).then(function () {
            return new Promise(function (resolve, reject) {
                if (!_this.Node.Connected) {
                    reject(new DSError_1.DSError(DSError_1.DSError.Codes.NOT_CONNECTED, 'Not connected.'));
                    return;
                }
                var argValues = new Array();
                argValues.push(event);
                args.forEach(function (arg) {
                    argValues.push(arg);
                });
                argValues.push(function (error, result) {
                    if (error) {
                        if (error.name === 'DSError') {
                            reject(DSError_1.DSError.fromJSON(error));
                        }
                        else {
                            reject(new DSError_1.DSError(DSError_1.DSError.Codes.UNKNOWN, 'Unable to deserialize error received from server.'));
                        }
                    }
                    else {
                        resolve(result);
                    }
                });
                _this.Node.emit.apply(_this.Node, argValues);
            });
        });
    };
    ServerNodeClientController.prototype.sendCommand = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return this._sendEvent(event, args);
    };
    ServerNodeClientController.prototype.sendCommandExpectResponse = function (TType, event) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return this._sendEvent(event, args).then(function (result) {
            return new Promise(function (resolve, reject) {
                if (TType !== null) {
                    try {
                        resolve(Serializer_1.Serializer.deserialize(TType, result));
                    }
                    catch (e) {
                        reject(new DSError_1.DSError(DSError_1.DSError.Codes.DESERIALIZATION_FAILED, e));
                    }
                }
                else {
                    resolve(result);
                }
            });
        });
    };
    ServerNodeClientController.prototype.sendCommandExpectResponseArray = function (TType, event) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return this._sendEvent(event, args).then(function (result) {
            return new Promise(function (resolve, reject) {
                if (TType !== null) {
                    try {
                        resolve(Serializer_1.Serializer.deserializeArray(TType, result));
                    }
                    catch (e) {
                        reject(new DSError_1.DSError(DSError_1.DSError.Codes.DESERIALIZATION_FAILED, e));
                    }
                }
                else {
                    resolve(result);
                }
            });
        });
    };
    ServerNodeClientController.prototype._awaitConnection = function (timeout) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.Node.Connected) {
                resolve(_this.Node);
            }
            else {
                _this._awaitTimeoutId = setTimeout(function () {
                    _this._awaitTimeoutId = null;
                    _this._awaitResolve = null;
                    _this.Node.disconnect();
                    reject(DSError_1.DSError.create(DSError_1.DSError.Codes.NOT_CONNECTED, 'not connected.'));
                }, timeout);
                _this._awaitResolve = function () {
                    clearTimeout(_this._awaitTimeoutId);
                    _this._awaitTimeoutId = null;
                    _this._awaitResolve = null;
                    resolve(_this.Node);
                };
            }
        });
    };
    return ServerNodeClientController;
}());
exports.ServerNodeClientController = ServerNodeClientController;
BackboneEvents.mixin(ServerNodeClientController.prototype);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ServerNodeClientController;

//# sourceMappingURL=ServerNodeClientController.js.map
