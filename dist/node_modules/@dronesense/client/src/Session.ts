import { ServerNodeClientController } from './common/ServerNodeClientController';
import { IServerNodeClient } from './common/IServerNodeClient';
import { ISession, constants as ISessionConstants } from '@dronesense/core/lib/common/ISession';
import { IDrone } from '@dronesense/core/lib/common/IDrone';
import { Drone } from './Drone';

export class Session extends ServerNodeClientController implements ISession {
	private _cachedDrones: { [index: string]: Drone };

	private _eventHandlers = {
		masterConnected: (username: string) => {
			this.trigger(ISessionConstants.events.MASTER_CONNECTED, username);
		},
		masterDisconnected: (username: string) => {
			this.trigger(ISessionConstants.events.MASTER_DISCONNECTED, username);
		},
		slaveRequestingConnection: (username: string, cb: (accepted: boolean) => void) => {
			this.trigger(ISessionConstants.events.SLAVE_REQUESTING_CONNECTION, username, cb);
		},
		slaveRequestingMaster: (username: string, cb: (accepted: boolean) => void) => {
			this.trigger(ISessionConstants.events.SLAVE_REQUESTING_MASTER, username, cb);
		},
		slaveConnected: (username: string) => {
			this.trigger(ISessionConstants.events.SLAVE_CONNECTED, username);
		},
		slaveDisconnected: (username: string) => {
			this.trigger(ISessionConstants.events.SLAVE_DISCONNECTED, username);
		},
		sessionEnded: () => {
			this.leaveSession();
			this.trigger(ISessionConstants.events.SESSION_ENDED);
		}
	};

	constructor(serverNodeClient: IServerNodeClient) {
		super(serverNodeClient);
		this._cachedDrones = {};
	}

	public get Id(): string {
		return <string>this._properties['Id'];
	}

	public get Name(): string {
		return <string>this._properties['Name'];
	}

	public get Color(): string {
		return <string>this._properties['Color'];
	}

	protected _onConnected(socket: IServerNodeClient): void {
		socket.on(ISessionConstants.events.MASTER_CONNECTED, this._eventHandlers.masterConnected);
		socket.on(ISessionConstants.events.MASTER_DISCONNECTED, this._eventHandlers.masterDisconnected);
		socket.on(ISessionConstants.events.SLAVE_REQUESTING_CONNECTION, this._eventHandlers.slaveRequestingConnection);
		socket.on(ISessionConstants.events.SLAVE_REQUESTING_MASTER, this._eventHandlers.slaveRequestingMaster);
		socket.on(ISessionConstants.events.SLAVE_CONNECTED, this._eventHandlers.slaveConnected);
		socket.on(ISessionConstants.events.SLAVE_DISCONNECTED, this._eventHandlers.slaveDisconnected);
		socket.on(ISessionConstants.events.SESSION_ENDED, this._eventHandlers.sessionEnded);
    }

    protected _onDisconnected(socket: IServerNodeClient): void {
		socket.off(ISessionConstants.events.MASTER_CONNECTED, this._eventHandlers.masterConnected);
		socket.off(ISessionConstants.events.MASTER_DISCONNECTED, this._eventHandlers.masterDisconnected);
		socket.off(ISessionConstants.events.SLAVE_REQUESTING_CONNECTION, this._eventHandlers.slaveRequestingConnection);
		socket.off(ISessionConstants.events.SLAVE_REQUESTING_MASTER, this._eventHandlers.slaveRequestingMaster);
		socket.off(ISessionConstants.events.SLAVE_CONNECTED, this._eventHandlers.slaveConnected);
		socket.off(ISessionConstants.events.SLAVE_DISCONNECTED, this._eventHandlers.slaveDisconnected);
		socket.off(ISessionConstants.events.SESSION_ENDED, this._eventHandlers.sessionEnded);
    }

	connect(username: string, clientToken?: string): Promise<string> {
		return this.Node.connect(username).then(() => {
			return this.sendCommand<string>(ISessionConstants.commands.CONNECT_TO_SESSION, clientToken).then((address) => {
				return address;
			});
		});
	}

	// bug: this promise is not returning because the node disconnects us as a result
	// of this command. No timeout occurs because of this as well. Both of these bugs
	// should probably be analyzed and fixed.
	public leaveSession(): Promise<void> {
		// return this.Socket.sendCommand<void>(ISessionConstants.commands.DISCONNECT_FROM_SESSION);
		return new Promise<void>((resolve, reject) => {
			this.Node.disconnect();
			resolve();
		});
	}

	public endSession(): Promise<void> {
		return this.sendCommand<void>(ISessionConstants.commands.END_SESSION).then(() => {
			// when a client requests to end a session, it doesn't receive a SESSION_ENDED event. Instead
			// it should disconnect from the ended session here.
			return this._eventHandlers.sessionEnded();
		});
	}

	public requestMaster(): Promise<void> {
		return this.sendCommand<void>(ISessionConstants.commands.REQUEST_MASTER);
	}

	public getMaster(): Promise<string> {
		return this.sendCommand<string>(ISessionConstants.commands.GET_MASTER);
	}

	public getSlaves(): Promise<string[]> {
		return this.sendCommand<string[]>(ISessionConstants.commands.GET_SLAVES);
	}

	public getDrones(): Promise<Array<IDrone>> {
		return this.sendCommand<Array<string>>(ISessionConstants.commands.GET_DRONES).then((droneNamespaces: Array<string>) => {

			droneNamespaces.forEach((droneNs: string) => {
				if (!this._cachedDrones[droneNs]) {
					var drone = new Drone(this.Node.spawn(droneNs));
					this._cachedDrones[droneNs] = drone;
				}
			});

			// return cached drones
			return Object.keys(this._cachedDrones).map((key: string) => {
				return this._cachedDrones[key];
			});
		});
	}
}

export default Session;
