import { ServerNodeClientController } from './common/ServerNodeClientController';
import { IServerNodeClient } from './common/IServerNodeClient';
import { ISessionManager, constants as ISessionManagerConstants } from '@dronesense/core/lib/common/ISessionManager';
import { ISession } from '@dronesense/core/lib/common/ISession';
import { Session } from './Session';
import { IDroneMetadata } from '@dronesense/core/lib/common/metadata/IDroneMetadata';
import { ISessionMetadata } from '@dronesense/core/lib/common/metadata/ISessionMetadata';
import { ServerNodeClient } from './common/IServerNodeClient';
import { DSError } from '@dronesense/core/lib/common/DSError';

export class SessionManager extends ServerNodeClientController implements ISessionManager {
	private _eventHandlers = {
		sessionCreated: (sessionMetadata: ISessionMetadata) => {
			this.trigger(ISessionManagerConstants.events.SESSION_CREATED, sessionMetadata);
		},
		sessionDestroyed: (id: string) => {
			this.trigger(ISessionManagerConstants.events.SESSION_DESTROYED, id);
		}
	};

    constructor(serverNodeClient: IServerNodeClient) {
        super(serverNodeClient);
    }

	protected _onConnected(socket: IServerNodeClient): void {
		socket.on(ISessionManagerConstants.events.SESSION_CREATED, this._eventHandlers.sessionCreated);
		socket.on(ISessionManagerConstants.events.SESSION_DESTROYED, this._eventHandlers.sessionDestroyed);
	}

	protected _onDisconnected(socket: IServerNodeClient): void {
		socket.off(ISessionManagerConstants.events.SESSION_CREATED, this._eventHandlers.sessionCreated);
		socket.off(ISessionManagerConstants.events.SESSION_DESTROYED, this._eventHandlers.sessionDestroyed);
	}

	public createSession(sessionName: string, color: string, drones: Array<IDroneMetadata>): Promise<ISession> {
		return new Promise<ISession>((resolve, reject) => {

			// Validation:
			//  - all droneHostIds must be the same.
			//  - no duplicate droneIds allowed.
			var lastDroneHostId: string = null;

			drones.forEach((drone) => {
				if (lastDroneHostId !== null && drone.droneHostId !== lastDroneHostId) {
					// failure, all droneHostIds don't match.
					return reject(DSError.create(DSError.Codes.CMD_FAILED, 'all drones must be from the same drone host.'));
				}
				lastDroneHostId = drone.droneHostId;
			});

			// flatten the metadata into a list of droneIds
			let droneIds: Array<string> = drones.map((droneMetadata) => {
				return droneMetadata.id;
			});

			return this.sendCommand<string>(ISessionManagerConstants.commands.CREATE_SESSION, sessionName, color, lastDroneHostId, droneIds).then((address: string) => {
				// if the session didn't provide an IP, fallback to the original hostname used
				// to connect to the droneSenseService.
				var addressComponents = address.split(':');
				if (addressComponents[0] === '0.0.0.0') {

					var hostComponents = this.Node.ClientInfo.Address.split(':');
					address = hostComponents[0] + ':' + hostComponents[1] + ':' + addressComponents[1]; // original-host-name:port
				}

				var session = new Session(ServerNodeClient.create(address));

				return session.connect(this.Node.ClientInfo.Username, null).then((role: string) => {
					resolve(session);
				});
			});
		});
	}

	public getSessions(): Promise<Array<ISessionMetadata>> {
		return this.sendCommand<Array<ISessionMetadata>>(ISessionManagerConstants.commands.GET_SESSIONS);
	}

    public joinSession(metadata: ISessionMetadata, timeoutMs: number): Promise<ISession> {
		return this.sendCommand<{ clientToken: string, address: string }>(ISessionManagerConstants.commands.JOIN_SESSION, metadata.id, timeoutMs).then((result: { clientToken: string, address: string }) => {
			// if the session didn't provide an IP, fallback to the original hostname used
			// to connect to the droneSenseService.
			var addressComponents = result.address.split(':');
			if (addressComponents[0] === '0.0.0.0') {

				var hostComponents = this.Node.ClientInfo.Address.split(':');
				result.address = hostComponents[0] + ':' + hostComponents[1] + ':' + addressComponents[1]; // original-host-name:port
			}

			var session = new Session(ServerNodeClient.create(result.address));

			return session.connect(this.Node.ClientInfo.Username, result.clientToken).then((role: string) => {
				return session;
			});
		});
	}
}

export default SessionManager;
