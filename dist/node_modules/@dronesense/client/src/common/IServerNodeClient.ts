import BackboneEvents = require('backbone-events-standalone');
import { DSError } from '@dronesense/core/lib/common/DSError';
import { IClientInfo, ClientInfo } from './IClientInfo';

export class ServerNodeClient implements IServerNodeClient {
    // cached values shared between all nodes in a single tree
    private _clientInfo: IClientInfo;

    // node hierarchy fields
    private _parent: ServerNodeClient;
    private _children: Array<ServerNodeClient>;

    // socket.io information
	private _socket: SocketIOClient.Socket = null;

	// namespace string of this node (i.e. '/flightController')
    private _nsString: string;

    // promise completions
    private _connectResolve: ( value?: void | Thenable<void>) => void;
    private _connectReject: (error?: any) => void;
    private _disconnectResolve: ( value?: void | Thenable<void>) => void;

    // singular callbacks
    public onConnected: (socket: IServerNodeClient) => void = null;
    public onDisconnected: (socket: IServerNodeClient) => void = null;
    public onConnectError: (socket: IServerNodeClient, error: any) => void = null;

    // Events
	public on(event: string, fn: Function): IServerNodeClient {
		this._socket.on(event, fn);
		return this;
	}
    public off(event: string, fn?: Function): IServerNodeClient {
        this._socket.off(event, fn);
        return this;
    }

    private _eventHandlers = {
        onConnect: () => {
            if (this.onConnected !== null) {
                this.onConnected(this);
            }

            // is there a connect() promise waiting?
            if (this._connectResolve) {
                this._connectResolve();
            }
        },
        onDisconnect: (reason: any) => {
            this._socket.off('connect', this._eventHandlers.onConnect);
            this._socket.off('disconnect', this._eventHandlers.onDisconnect);
            this._socket.off('connect_error', this._eventHandlers.onConnectError);
            this._socket.off('error', this._eventHandlers.onError);

            if (this.onDisconnected !== null) {
                this.onDisconnected(this);
            }

            // is there a disconnect() promise waiting?
            if (this._disconnectResolve) {
                this._disconnectResolve();
            }
        },
        onConnectError: (error: any) => {
            if (this.onConnectError !== null) {
                this.onConnectError(this, error);
            }

            // is there a connect() promise waiting?
            if (this._connectReject) {
                this._connectReject(DSError.create(DSError.Codes.CONNECT_FAILED, 'an error occurred while connecting', error));
            }
        },
        onError: (error: any) => {
            this._eventHandlers.onConnectError(error);
            this._socket.off('connect', this._eventHandlers.onConnect);
            this._socket.off('disconnect', this._eventHandlers.onDisconnect);
            this._socket.off('connect_error', this._eventHandlers.onConnectError);
            this._socket.off('error', this._eventHandlers.onError);
        }
    };

    /**
     * Creates a ClientSocket.
     * @param {IClientInfo} clientInfo - The clientInfo shared by all nodes in this tree.
	 * @param {string} [ns] - The namespace if this is a child node.
     */
    constructor(clientInfo: IClientInfo, ns?: string) {
        this._clientInfo = clientInfo;
        this._nsString = ns;
        this._children = new Array<ServerNodeClient>();
    }

    get ClientInfo(): IClientInfo {
        return this._clientInfo;
    }

	getConnectionString(excludeHostAddress?: boolean): string {
        if (!this._parent && excludeHostAddress) {
            return '';
        } if (!this._parent) {
			return !!this._nsString ? this._clientInfo.Address + this._nsString : this._clientInfo.Address;
		} else {
			return this._parent.getConnectionString(excludeHostAddress) + this._nsString;
		}
	}

    get Parent(): ServerNodeClient {
        return this._parent;
    }
    set Parent(value: ServerNodeClient) {
        this._parent = value;
    }
    get Children(): Array<ServerNodeClient> {
        return this._children;
    }

    static create(address: string): IServerNodeClient {
        return new ServerNodeClient(new ClientInfo(address));
    }

    spawn(ns: string): IServerNodeClient {
        var childNode = new ServerNodeClient(this._clientInfo, ns);
        childNode._parent = this;
        this._children.push(childNode);

        // if the parent is connected, immediately connect the child
        if (this.Connected) {
            childNode.connect();
        }

        return childNode;
    }

	release(): void {
		if (this.Parent) {
			var idx = this.Parent.Children.indexOf(this);
			if (idx >= 0) {
				this.Parent.Children.splice(idx, 1);
			}
			this.Parent.Children.splice(this.Parent.Children.indexOf(this), 1);
			this.Parent = null;
		}

        // if this node was connected, immediately disconnect it
        if (this.Connected) {
            this.disconnect();
        }
	}

    get Connected(): boolean {
        return !!this._socket && this._socket.connected;
    }

    connect(username?: string): Promise<void> {
        return new Promise<void>((resolve, reject) => {

            // are we already connected? this will be detected in the root node.
            if (this.Connected) {
                return reject(DSError.create(DSError.Codes.CONNECT_FAILED, 'Already connected.'));
            }

            // store promises to be resolved when event callbacks happen in _eventHandlers
            this._connectResolve = resolve;
            this._connectReject = reject;

            console.log('Connecting to: ' + this.getConnectionString(false));

            // create the socket/namespace connection
            if (!this._parent) {
                if (!username) {
                    throw new Error('a username is required to connect to a root node.');
                }

                // store the username
                this._clientInfo.Username = username;

                // create a new manager for the root object
                this._socket = io(this.getConnectionString(false), {
                    query: 'username=' + username,
                    reconnection: false
                });
            } else {
                // use the parent manager for children, so they retain the same IDs
                this._socket = this._parent._socket.io.socket(this.getConnectionString(true));
            }

            this._socket.on('connect', this._eventHandlers.onConnect);
            this._socket.on('disconnect', this._eventHandlers.onDisconnect);
            this._socket.on('connect_error', this._eventHandlers.onConnectError);
            this._socket.on('error', this._eventHandlers.onError);
        }).then(() => {
            // we resolved, nullify the stored promises
            this._connectReject = null;
            this._connectResolve = null;

            return Promise.all(this._children.map((child) => {
                // NOTE: if a child rejects, the root parent node connection failed, and all
                // nodes will have disconnected. Connect should be called again on the root node
                // by the user if this happens.
                return child.connect();
            })).then(() => {
                // success
                return;
            });
        }).catch((error: any) => {
            // we resolved, nullify the stored promises
            this._connectReject = null;
            this._connectResolve = null;

            throw error;
        });
    }

    disconnect(): Promise<void> {
        return new Promise<void>((resolve, reject) => {
            if (!this._socket.connected) {
                resolve();
            } else {
                // store promises to be resolved when event callbacks happen in _eventHandlers
                this._disconnectResolve = resolve;

                return Promise.all(this._children.map((child) => {
                    // NOTE: if a child rejects, the root parent node connection failed, and all
                    // nodes will have disconnected. Connect should be called again on the root node
                    // by the user if this happens.
                    return child.disconnect();
                })).then(() => {
                    // disconnect this node
                    console.log('Disconnecting from: ' + this.getConnectionString(false));
                    this._socket.disconnect();
                });
            }
        }).then(() => {
            // we resolved, nullify the stored promises
            this._disconnectResolve = null;
        });
    }

    emit(event: string, ...args: any[]): IServerNodeClient {
        this._socket.emit.apply(this._socket, arguments);
        return this;
    }
}

export interface IServerNodeClient {
	/**
	 * Information about this client connection.
	 */
    ClientInfo: IClientInfo;

    /**
     * @property {boolean} Connected - True if this client socket is connected.
     */
    Connected: boolean;

    // delegate callbacks
    onConnected: (socket: IServerNodeClient) => void;
    onDisconnected: (socket: IServerNodeClient) => void;
    onConnectError: (socket: IServerNodeClient, error: any) => void;

    // messaging callbacks
    on(event: string, fn: Function): IServerNodeClient;
    off(event: string, fn?: Function): IServerNodeClient;

    /**
     * Spawns a child node of this node using the specified namespace.
     * @param {string} ns - The child namespace of the node.
     * @returns {IServerNodeClient} The child node.
     */
    spawn(ns: string): IServerNodeClient;

    /**
     * Disconnects and detaches this node for garbage collection.
     */
    release(): void;

    /**
     * Connects to the socket.
     * @returns {Promise<void>} a promise.
     */
    connect(username?: string): Promise<void>;

    /**
     * Disconnects from the socket.
     * @returns {Promise<void>} a promise.
     */
    disconnect(): Promise<void>;

    /**
     * Emits a message to the server node.
     * @returns {IServerNodeClient} this IServerNodeClient.
     */
    emit(event: string, ...args: any[]): IServerNodeClient;
}

export default IServerNodeClient;
