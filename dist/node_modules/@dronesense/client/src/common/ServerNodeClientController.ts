import BackboneEvents = require('backbone-events-standalone');
import * as Serialization from '@dronesense/core/lib/utility/Serialization';
import { Serializer } from '@dronesense/core/lib/utility/Serializer';
import { IEventEmitterInternal } from '@dronesense/core/lib/common/IEventEmitter';
import { IServerNodeClient, ServerNodeClient } from './IServerNodeClient';
import { DSError } from '@dronesense/core/lib/common/DSError';
import { Events, Commands } from '@dronesense/core/lib/common/Events';

/**
 * How long to await the connection before failing to send a command.
 */
const AWAIT_CONNECTION_TIMEOUT: number = 1000;

export class ServerNodeClientController implements IEventEmitterInternal {
    private _serverNodeClient: IServerNodeClient;

    // connecting on-the-fly
    private _awaitTimeoutId: any = null;
    private _awaitResolve: () => void = null;

    // server properties
    protected _properties: { [index: string]: any };

	// Events

	on: (eventName: string, callback?: Function, context?: any) => any;
	once: (events: string, callback: Function, context?: any) => any;
	off: (eventName?: string, callback?: Function, context?: any) => any;
	trigger: (eventName: string, ...args: any[]) => any;

    private __eventHandlers = {
		propertyChanged: (name: string, value: any) => {
			this._properties[name] = value;
            this._onPropertyChanged(name, value);
		}
	};

    constructor(serverNodeClient?: IServerNodeClient) {
        this._properties = {};

        // if serverNodeClient isn't provided, this is probably the deserializer instansiating it
        if (serverNodeClient) {
            this._setServerNodeClient(serverNodeClient);
        }
    }

    private _setServerNodeClient(serverNodeClient: IServerNodeClient) {
        this._serverNodeClient = serverNodeClient;
        this._serverNodeClient.onConnected = (socket: IServerNodeClient) => {

            this.Node.on(Events.PROPERTY_CHANGED, this.__eventHandlers.propertyChanged);

            // tell the server node to emit ALL properties to this client
            this.sendCommand<void>(Commands.REFRESH_PROPERTIES);

            // is there an awaitConnection promise waiting?
            if (this._awaitResolve !== null) {
                this._awaitResolve();
            }

            this._onConnected(socket);
        };
        this._serverNodeClient.onDisconnected = (socket: IServerNodeClient) => {

            this.Node.off(Events.PROPERTY_CHANGED, this.__eventHandlers.propertyChanged);

            this._onDisconnected(socket);
        };
        this._serverNodeClient.onConnectError = this._onConnectError.bind(this);
    }

    /**
	 * @property {IClientSocket} Socket - The client socket.
	 */
    protected get Node(): IServerNodeClient {
        return this._serverNodeClient;
    }

	/**
	 * Called when the client socket is connected.
	 * @param {IClientSocket} socket - The client socket.
	 */
    protected _onConnected(socket: IServerNodeClient): void {
        // overridable
    }

	/**
	 * Called when the client socket is disconnected.
	 * @param {IClientSocket} socket - The client socket.
	 */
    protected _onDisconnected(socket: IServerNodeClient): void {
        // overridable
    }

    /**
     * Called when the client socket has a connection error.
     * @param {IServerNodeClient} socket - The client socket.
     * @param {any} error - The error.
     */
    protected _onConnectError(socket: IServerNodeClient, error: any): void {
        // overridable
    }

    /**
     * Called when a value in the _properties object changes based
     * on an event received from the server.
     * @param {string} name - The name of the property that changed.
     * @param {any} value - The new value of the property.
     */
    protected _onPropertyChanged(name: string, value: any) {
        // overridable
    }

    private _sendEvent(event: string, args: any[]) : Promise<any> {
        return this._awaitConnection(AWAIT_CONNECTION_TIMEOUT).then(() => {
            return new Promise<any>((resolve, reject) => {

                // if we aren't connected, reject with an error
                if (!this.Node.Connected) {
                    reject(new DSError(DSError.Codes.NOT_CONNECTED, 'Not connected.'));
                    return;
                }

                // create the arguments to emit to the server
                var argValues: Array<any> = new Array<any>();
                argValues.push(event);
                args.forEach((arg: any) => {
                    argValues.push(arg);
                });
                argValues.push((error: any, result?: any) => {
                    if (error) {
                        if (error.name === 'DSError') {
                            reject(DSError.fromJSON(error));
                        } else {
                            reject(new DSError(DSError.Codes.UNKNOWN, 'Unable to deserialize error received from server.'));
                        }
                    } else {
                        resolve(result);
                    }
                });

                // emit to the server
                this.Node.emit.apply(this.Node, argValues);
            });
        });
    }

    /**
     * Sends an event and its arguments to the server to be handled.
     * @param {string} event - The event name.
     * @param {any[]} args - The event arguments.
     * @return {Promise<T>} A promise with a parameter type of T.
     */
	protected sendCommand<T>(event: string, ...args: any[]) : Promise<T> {
        return this._sendEvent(event, args);
	}

    /**
     * Sends a command to the server-side socket and expects a serializable response in return.
     * @param {T} TType - The concrete type of T to deserialize the response to.
     * @param {string} event - The event string to route this command to on the server.
     * @param {any[]} args - The arguments of the event.
     * @return {Promise<T>} A promise with an object of type T.
     */
	protected sendCommandExpectResponse<T extends Serialization.ICoding>(TType: { new() : T }, event: string, ...args: any[]) : Promise<T> {
        return this._sendEvent(event, args).then((result: any) => {
           return new Promise<T>((resolve, reject) => {
                if (TType !== null) {
                    // Serialization handling
                    try {
                        resolve(Serializer.deserialize<T>(TType, result));
                    } catch (e) {
                        reject(new DSError(DSError.Codes.DESERIALIZATION_FAILED, e));
                    }
                } else {
                    resolve(result);
                }
           });
        });
	}

    /**
     * Sends a command to the server-side socket and expects a serializable array of responses in return.
     * @param {T} TType - The concrete type of T to deserialize the response to.
     * @param {string} event - The event string to route this command to on the server.
     * @param {any[]} args - The arguments of the event.
     * @return {Promise<T>} A promise with an array of objects of type T.
     */
	protected sendCommandExpectResponseArray<T extends Serialization.ICoding>(TType: { new() : T }, event: string, ...args: any[]) : Promise<Array<T>> {
        return this._sendEvent(event, args).then((result: any) => {
           return new Promise<Array<T>>((resolve, reject) => {
                if (TType !== null) {
                    // Serialization handling
                    try {
                        resolve(Serializer.deserializeArray<T>(TType, result));
                    } catch (e) {
                        reject(new DSError(DSError.Codes.DESERIALIZATION_FAILED, e));
                    }
                } else {
                    resolve(result);
                }
           });
        });
	}

    /**
     * Awaits for the connection to be established. Used internally to postpone emitting
     * events until the connection is fully established.
     * @param {number} timeout - How long to wait before rejecting w/a timeout.
     */
    private _awaitConnection(timeout: number): Promise<IServerNodeClient> {
        return new Promise<IServerNodeClient>((resolve, reject) => {
            if (this.Node.Connected) {
                resolve(this.Node);
            } else {
                // the timeout
                this._awaitTimeoutId = setTimeout(() => {
                    this._awaitTimeoutId = null;
                    this._awaitResolve = null;
                    this.Node.disconnect();
                    reject(DSError.create(DSError.Codes.NOT_CONNECTED, 'not connected.'));
                }, timeout);

                // the resolve
                this._awaitResolve = () => {
                    clearTimeout(this._awaitTimeoutId);
                    this._awaitTimeoutId = null;
                    this._awaitResolve = null;
                    resolve(this.Node);
                };
            }
        });
    }
}

BackboneEvents.mixin(ServerNodeClientController.prototype);

export default ServerNodeClientController;
