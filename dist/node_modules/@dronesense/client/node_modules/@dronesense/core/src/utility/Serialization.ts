export interface ICoding {
    __type__: string;
    initWithCoder(coder: IDecoder) : void;
    encodeWithCoder(coder: IEncoder) : void;
}

export interface IEncoder {
    encodeObjectForKey(obj: ICoding, key: string) : void;
    encodeArrayForKey(values: Array<any>, key: string) : void;
    encodeBooleanForKey(value: boolean, key: string) : void;
    encodeNumberForKey(value: number, key: string) : void;
    encodeStringForKey(value: string, key: string) : void;
    encodeDateForKey(value: Date, key: string) : void;
}

export interface IDecoder {
    // TODO:
    // flat objects
    // to/from arrays as the root object

    /**
     * decodes an object using its __type__ property, and the IObjectFactory.
     */
    decodeObjectForKey(key: string): any;

    /**
     * decodes an object to an explicit type, ignoring __type__, and the IObjectFactory.
     *  Note that if the explicit type makes any calls to decodeObjectForKey, decodeArrayForKey, etc
     *  during deserialization, that __type__ and IObjectFactory will be used in those calls.
     */
    decodeObjectOfTypeForKey<T extends ICoding>(clazz: { new (): T; }, key: string): any;
    decodeArrayForKey(key: string): Array<any>;
    decodeBooleanForKey(key: string): boolean;
    decodeNumberForKey(key: string): number;
    decodeStringForKey(key: string): string;
    decodeDateForKey(key: string): Date;
}

export interface IObjectFactory {
    createInstance(type: string): Object&ICoding;
}

/**
 * Serializer
 */
export class Serializer implements IEncoder {
    private _json: any;

    constructor() {
        // leave empty
    }

    // note: use a new instance of serializer when calling this
    serialize<T extends ICoding>(obj: T) : any {
        this._json = {};
        this._json.__type__ = obj.__type__; // auto-serialize __type__
        obj.encodeWithCoder(this);
        return this._json;
    }

    // note: use a new instance of serializer when calling this
    private serializeObject(obj: Object&ICoding) : any {
        this._json = {};
        this._json.__type__ = obj.__type__; // auto-serialize __type__
        obj.encodeWithCoder(this);
        return this._json;
    }

    private encode(value: any) {
        if (typeof value === 'object') {
            if (Array.isArray(value)) {
                return this.encodeArray(value);
            } else if (value.__type__) {
                var serializer = new Serializer();
                return serializer.serialize(value);
            } else {
                // throw exception?
            }
        } else {
            return value;
        }
    }

    private encodeArray(values: Array<any>) : any {
        var encodedArray: Array<any> = new Array<any>();
        values.forEach((v: any) => {
            encodedArray.push(this.encode(v));
        });
        return encodedArray;
    }

    encodeObjectForKey(obj: ICoding, key: string) : void {
        if (obj) {
            var serializer = new Serializer();
            this._json[key] = serializer.serialize(obj);
        } else {
            this._json[key] = null;
        }
    }
    encodeArrayForKey(values: Array<any>, key: string) : void {
        var encodedArray : Array<any> = new Array<any>();
        values.forEach((v) => {
            encodedArray.push(this.encode(v));
        });
        this._json[key] = encodedArray;
    }
    encodeBooleanForKey(value: boolean, key: string) : void {
        this._json[key] = value;
    }
    encodeNumberForKey(value: number, key: string) : void {
        this._json[key] = value;
    }
    encodeStringForKey(value: string, key: string) : void {
        this._json[key] = value;
    }
    encodeDateForKey(value: Date, key: string) : void {
        this._json[key] = value;
    }
}

/**
 * Deserializer
 */
export class Deserializer implements IDecoder {
    private _json: any;
    private _objectFactory: IObjectFactory;

    constructor(objectFactory?: IObjectFactory) {
        if (objectFactory) {
            this._objectFactory = objectFactory;
        } else {
            this._objectFactory = {
                createInstance(type: string) : any {
                    return null;
                }
            };
        }
    }

    // note: use a new instance of deserializer when calling this
    deserialize<T extends ICoding>(clazz: { new (): T; }, json: any) : T {
        this._json = json;
        var obj = new clazz();
        obj.initWithCoder(this);
        return obj;
    }

    // note: use a new instance of deserializer when calling this
    private deserializeObject(json: any) : Object {
        this._json = json;
        var type = this._json.__type__;
        var obj = this._objectFactory.createInstance(type);
        obj.initWithCoder(this);
        return obj;
    }

    // value could be json, primitive, or object
    private decode(value: any) : any {
        if (typeof value === 'object') {
            // is it an array?
            if (Array.isArray(value)) {
                return this.decodeArray(value);
            // if not, it's a normal object
            } else if (value.__type__) {
                var deserializer = new Deserializer(this._objectFactory);
                return deserializer.deserializeObject(value);
            } else {
                // throw exception?
            }
        } else {
            return value;
        }
    }

    private decodeArray(values: Array<any>) {
        var decodedArray: Array<any> = new Array<any>();
        values.forEach((v: any) => {
            decodedArray.push(this.decode(v));
        });
        return decodedArray;
    }

    decodeObjectForKey(key: string): any {
        if (this._json[key]) {
            var deserializer = new Deserializer(this._objectFactory);
            return deserializer.deserializeObject(this._json[key]);
        } else {
            return null;
        }
    }
    decodeObjectOfTypeForKey<T extends ICoding>(clazz: { new (): T; }, key: string): any {
        var deserializer = new Deserializer(this._objectFactory);
        return deserializer.deserialize<T>(clazz, this._json[key]);
    }
    decodeArrayForKey(key: string): Array<any> {
        return this.decodeArray(this._json[key]);
    }
    decodeBooleanForKey(key: string): boolean {
        return this._json[key];
    }
    decodeNumberForKey(key: string): number {
        return this._json[key];
    }
    decodeStringForKey(key: string): string {
        return this._json[key];
    }
    decodeDateForKey(key: string) {
        return this._json[key];
    }
}
