// Load Serialization Types
import * as Serialization from './Serialization';

class ObjectFactory implements Serialization.IObjectFactory {
    private _types : { [ index: string] : any };

    constructor() {
        this._types = {};
    }

    addType(type: string, clazz: { new (): Object; }) : void {
        this._types[type] = clazz;
    }

    createInstance(type: string): Object&Serialization.ICoding {
        if (this._types[type]) {
            return new this._types[type]();
        } else {
            throw new Error('\'' + type + '\' does not exist in ObjectFactory');
        }
    }
}

export class Serializer {
    private static _objectFactory = new ObjectFactory();

    /**
     * Add type to object mappings that object of "__type__" will be deserialized to.
     * Serializer.addType('DSDB_WaypointCommand', WaypointCommand); // example
     */
    static addType(type: string, clazz: { new (): Object; }) : void {
        Serializer._objectFactory.addType(type, clazz);
    }

    static serialize<T extends Serialization.ICoding>(obj: T) : any {
        var s = new Serialization.Serializer();
        return s.serialize(obj);
    }

    static serializeArray<T extends Serialization.ICoding>(objects: Array<T>): Array<any> {
        var encodedObjects = new Array<T>();
        objects.forEach((obj) => {
            encodedObjects.push(this.serialize<T>(obj));
        });
        return encodedObjects;
    }

    static deserialize<T extends Serialization.ICoding>(clazz: { new (): T; }, json: any) : T {
            var d = new Serialization.Deserializer(this._objectFactory);
            return d.deserialize(clazz, json);
    }

    static deserializeArray<T extends Serialization.ICoding>(clazz: { new(): T; }, jsonObjects: Array<any>) : Array<T> {
        var decodedObjects = new Array<T>();
        jsonObjects.forEach((obj) => {
            decodedObjects.push(this.deserialize<T>(clazz, obj));
        });
        return decodedObjects;
    }

    // note: this only deserializes to FLAT objects. If you need hierarchical objects,
	// then use ICoding, and the other deserialize methods.
	static deserializeToFlatObject<T extends any>(c: { new (): T; }, json: any): T {
		var instance = new c();
		for (var prop in json) {
			if (!json.hasOwnProperty(prop)) {
				continue;
			}

			instance[prop] = json[prop];
		}

		return instance;
	}

    // note: this only deserializes to FLAT objects. If you need hierarchical objects,
	// then use ICoding, and the other deserialize methods.
	static deserializeToFlatObjects<T extends any>(c: { new (): T; }, jsonArray: Array<any>): Array<T> {
		var instances: Array<T> = new Array<T>();
		jsonArray.forEach((json: any) => {
			instances.push(this.deserializeToFlatObject<T>(c, json));
		});

		return instances;
	}
}

export default Serializer;
