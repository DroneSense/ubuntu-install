/* tslint:disable: no-bitwise */

import GeoPoint from '../models/GeoPoint';

export class Conversions {

    static readableDistance(distance: number, isMetric: boolean): string {
        var distanceStr: string;

        if (isMetric) {
            // show metres when distance is < 1km, then show km
            if (distance > 1000) {
                distanceStr = (distance / 1000).toFixed(2) + ' km';
            } else {
                distanceStr = distance.toFixed(2) + ' m'; // Math.ceil(distance) + ' m';
            }
        } else {
            // yard calculation
            //distance *= 1.09361;
            distance *= 3.2808;

            if (distance > 5280) {
                distanceStr = (distance / 5280).toFixed(2) + ' miles';
            } else {
                distanceStr = Math.ceil(distance) + ' ft';
            }
        }

        return distanceStr;
    }

    static readableElevation(elevation: number, isMetric: boolean): string {
        var distanceStr: string;

        if (isMetric) {
            // show metres when distance is < 1km, then show km
                distanceStr = elevation.toFixed(2) + ' m'; // Math.ceil(distance) + ' m';
        } else {
            elevation *= 3.2808;

            distanceStr = Math.ceil(elevation) + ' ft';
        }

        return distanceStr;
    }

    static metersToFeet(elevation: number): number {
        return Math.ceil(elevation * 3.2808);
    }

    static feetToMeters(elevation: number): number {
        return parseFloat((elevation * 0.3048).toFixed(2));
    }

    static cmToIn(cm: number): number {
        return cm * 0.393701;
    }

    static inToCM(inches: number): number {
        return inches * 2.5400013716;
    }

    static readableArea(area: number, isMetric: boolean): string {
        var areaStr: string;

        if (isMetric) {
            if (area >= 10000) {
                areaStr = (area * 0.0001).toFixed(2) + ' ha';
            } else {
                areaStr = area.toFixed(2) + ' m&sup2;';
            }
        } else {
            area /= 0.836127; // Square yards in 1 meter

            if (area >= 3097600) { //3097600 square yards in 1 square mile
                areaStr = (area / 3097600).toFixed(2) + ' mi&sup2;';
            } else if (area >= 4840) {//48040 square yards in 1 acre
                areaStr = (area / 4840).toFixed(2) + ' acres';
            } else {
                areaStr = Math.ceil(area) + ' yd&sup2;';
            }
        }

        return areaStr;
    }

    static readableSpeed(speed: number, isMetric: boolean): string {
        var speedStr: string;

        if (isMetric) {
            speedStr = speed + ' m/s';
        } else {
            if (speed === 0) {
                return '0 mph';
            }
            speed = speed * 2.23694; // MPH per 1 meter

            speedStr = speed.toFixed(1) + ' mph';
        }

        return speedStr;
    }

    static geodesicArea(latLngs: Array<GeoPoint>): number {
        var pointsCount: number = latLngs.length,
            area: number = 0.0,
            d2r: number = Math.PI / 180,
            p1: GeoPoint, p2: GeoPoint;

        if (pointsCount > 2) {
            for (var i: number = 0; i < pointsCount; i++) {
                p1 = latLngs[i];
                p2 = latLngs[(i + 1) % pointsCount];
                area += ((p2.lng - p1.lng) * d2r) *
                    (2 + Math.sin(p1.lat * d2r) + Math.sin(p2.lat * d2r));
            }
            area = area * 6378137.0 * 6378137.0 / 2.0;
        }

        return Math.abs(area);
    }

    //The sign tells us whether we are north or south, east or west on the globe.
    //A nonzero hundreds digit tells us we're using longitude, not latitude!
    //The tens digit gives a position to about 1,000 kilometers. It gives us useful information about what continent or ocean we are on.
    //The units digit (one decimal degree) gives a position up to 111 kilometers (60 nautical miles, about 69 miles). It can tell us roughly what large state or country we are in.
    //The first decimal place is worth up to 11.1 km: it can distinguish the position of one large city from a neighboring large city.
    //The second decimal place is worth up to 1.1 km: it can separate one village from the next.
    //The third decimal place is worth up to 110 m: it can identify a large agricultural field or institutional campus.
    //The fourth decimal place is worth up to 11 m: it can identify a parcel of land. It is comparable to the typical accuracy of an uncorrected GPS unit with no interference.
    //The fifth decimal place is worth up to 1.1 m: it distinguish trees from each other. Accuracy to this level with commercial GPS units can only be achieved with differential correction.
    //The sixth decimal place is worth up to 0.11 m: you can use this for laying out structures in detail, for designing landscapes, building roa It should be more than good enough for tracking movements of glaciers and rivers. This can be achieved by taking painstaking measures with GPS, such as differentially corrected GPS.
    //The seventh decimal place is worth up to 11 mm: this is good for much surveying and is near the limit of what GPS-based techniques can achieve.
    //The eighth decimal place is worth up to 1.1 mm: this is good for charting motions of tectonic plates and movements of volcanoes. Permanent, corrected, constantly-running GPS base stations might be able to achieve this level of accuracy.
    //The ninth decimal place is worth up to 110 microns: we are getting into the range of microscopy. For almost any conceivable application with earth positions, this is overkill and will be more precise than the accuracy of any surveying device.
    //Ten or more decimal places indicates a computer or calculator was used and that no attention was paid to the fact that the extra decimals are useless. Be careful, because unless you are the one reading these numbers off the device, this can indicate low quality processing!

    // reduce to 7 decimal places which is 11mm
    static readableCoordinate(coordinate: number): string {
        return coordinate.toFixed(7);
    }

    static formatCoordinate(coordinate: number, digits: number): number {
        return parseFloat(coordinate.toFixed(digits));
    }

    // Calculate distance between two coordinate points
    static distanceToPoint(x1: number, y1: number, x2: number, y2: number): number {
        var xs: number = 0;
        var ys: number = 0;

        xs = x2 - x1;
        xs = xs * xs;

        ys = y2 - y1;
        ys = ys * ys;

        return Math.sqrt(xs + ys);
    }

    // Calculate the bearing between two lat/lng's
    static bearingFromCoordinates(lat1: number, long1: number, lat2: number, long2: number): number {
        var φ1: number = Conversions.toRadians(lat1), φ2: number = Conversions.toRadians(lat2);
        var Δλ: number = Conversions.toRadians(long2 - long1);
        var y: number = Math.sin(Δλ) * Math.cos(φ2);
        var x: number = Math.cos(φ1) * Math.sin(φ2) -
            Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
        var θ: number = Math.atan2(y, x);

        return (Conversions.toDegrees(θ) + 360) % 360;
    }

    // Calculate lat/lng given a position, bearing and distance
    static destinationPoint(point: GeoPoint, bearing: number, distance: number, radius?: number): GeoPoint {
        radius = 6371e3;

        var dis: number = distance / radius; // angular distance in radians
        var bear: number = Conversions.toRadians(bearing);

        var lat1: number = Conversions.toRadians(point.lat);
        var lng1: number = Conversions.toRadians(point.lng);

        var lat2: number = Math.asin(Math.sin(lat1) * Math.cos(dis) + Math.cos(lat1) * Math.sin(dis) * Math.cos(bear));
        var lng2: number = lng1 + Math.atan2(Math.sin(bear) * Math.sin(dis) * Math.cos(lat1), Math.cos(dis) - Math.sin(lat1) * Math.sin(lat2));

        lng2 = (lng2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // normalise to -180..+180°

        return new GeoPoint(Conversions.toDegrees(lat2), Conversions.toDegrees(lng2));
    }

    static distanceTo(point1: GeoPoint, point2: GeoPoint): number {

        var R: number = 6378137, // earth radius in meters
            d2r: number = Math.PI / 180,
            dLat: number = (point2.lat - point1.lat) * d2r,
            dLon: number = (point2.lng - point1.lng) * d2r,
            lat1: number = point1.lat * d2r,
            lat2: number = point2.lat * d2r,
            sin1: number = Math.sin(dLat / 2),
            sin2: number = Math.sin(dLon / 2);

        var a: number = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);

        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    static distance2(lat1: number, lng1: number, lat2: number, lng2: number): number {
        return Conversions.distanceTo(new GeoPoint(lat1, lng1), new GeoPoint(lat2, lng2));
    }

    // Convert to Radians
    static toRadians(degrees: number): number {
        return degrees * (Math.PI / 180);
    }

    // Convert to Degrees
    static toDegrees(radians: number): number {
        return radians * 180 / Math.PI;
    }

    // Check if number is even or odd
    static isOdd(num: number): boolean {
        return (num % 2) === 1;
    }

    static earthRadius(): number {
        return 40075016.68557849;
    }

    static calculateHeight(xDistance: number, yDistance: number, xPixels: number): number {
        return ((yDistance * xPixels) / xDistance);
    }

    static roundToTwo(num: number): number {
        return +num.toFixed(2);
    }

    static newGuid(): string {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c: any): string => {
            var r: any = Math.random() * 16 | 0, v: any = c === 'x' ? r : (r & 0x3 | 0x8 );
            return v.toString(16);
        });
    }

    static toInchesHG(mbPressure: number): number {
        return 0.0295300 * mbPressure;
    }

    static toMBPressure(inHg: number): number {
        return 33.8639 * inHg;
    }

    static getResolution(zoomLevel: number, latitudeCorrected: boolean, latitude?: number): number {
        if (latitudeCorrected) {
            return Conversions.earthRadius() * Math.cos(Conversions.toRadians(latitude)) / Math.pow(2, zoomLevel + 8);
        } else {
            return Conversions.earthRadius() / 256 / Math.pow(2, zoomLevel);
        }
    }

    // Convert DS Point to Leaflet Point
    static toLeafletLatLng(coordinate: GeoPoint): GeoPoint {
        return new GeoPoint(coordinate.lat, coordinate.lng);
    }

    static toLeafletLatLngArray(geoPoints: Array<GeoPoint>): Array<GeoPoint> {
        var latLngs: Array<GeoPoint> = [];

        for (var i: number = 0, len: number = geoPoints.length; i < len; i++) {
            latLngs.push(new GeoPoint(geoPoints[i].lat, geoPoints[i].lng));
        }

        return latLngs;
    }

    static toGeoPointArray(latLngs: Array<GeoPoint>): Array<GeoPoint> {
        var geoPoints: Array<GeoPoint> = [];

        for (var i: number = 0, len: number = latLngs.length; i < len; i++) {
            geoPoints.push(new GeoPoint(latLngs[i].lat, latLngs[i].lng));
        }

        return geoPoints;
    }

    static getMaxDistance(latLngs: Array<GeoPoint>, takeoff: GeoPoint): number {

        var max: number = 0;

        latLngs.forEach((latLng: GeoPoint): void => {
            if (max < Conversions.distanceTo(takeoff, latLng)) {
                max = Conversions.distanceTo(takeoff, latLng);
            }
        });

        return max;
    }

}

export class Sensor {

    static horizontalFOV(sensorWidth: number, focalLength: number): number {
        return Conversions.toDegrees((2 * Math.atan(sensorWidth / (2 * focalLength))));
    }

    static verticalFOV(sensorHeight: number, focalLength: number): number {
        return Conversions.toDegrees((2 * Math.atan(sensorHeight / (2 * focalLength))));
    }

    // Horizontal Coverage in Meters
    // =2*flightAltitude*TAN(RADIANS(horizontalFOV/2))
    static calculateHorizontalCoverage(altitude: number, horizontalFOV: number): number {
        return (2 * altitude * Math.tan(Conversions.toRadians(horizontalFOV / 2)));
    }

    // Vertical Coverage in Meters
    // =2*flightAltitude*TAN(RADIANS(verticalFOV/2))
    static calculateVerticalCoverage(altitude: number, verticalFOV: number): number {
        return (2 * altitude * Math.tan(Conversions.toRadians(verticalFOV / 2)));
    }
}
