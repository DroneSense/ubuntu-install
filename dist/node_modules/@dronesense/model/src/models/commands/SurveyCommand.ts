// import Command from '../../../models/command';
// import Camera from '../../../models/Camera';
// import GeoPoint from '../../../models/GeoPoint';
// import { AltGSDMode } from '../../../common/Enums';
// import { HeadingMode } from '../../../common/Enums';
// import { Conversions } from '../../../common/Utility';

// export class SurveyCommand extends Command {

//     // onImageAreaUpdated: LiteEvent<boolean> = new LiteEvent<boolean>();

//     // get ImageAreaUpdated(): ILiteEvent<boolean> {
//     //     return this.onImageAreaUpdated;
//     // }

//     constructor(id?: string, handle?: any) {
//         super('Survey', id, handle);

//         this.ImageAreaPolygon = [];
//         this.FlightPath = [];
//         this.ImageCapturePoints = [];

//         if (this.handle) {
//             this.hydrate(this.handle.data);
//             this.handle.on(this.handle.EVENTS.DATA_CHANGED, this.hydrate.bind(this));
//         }
//     }

//     _camera: Camera;

//     // This is enum type AltGSDMode
//     // Using any here to appease the compiler gods
//     AltGSDMode: any = 'Altitude';

//     // Altitude of the drone for the survey flight plan
//     Altitude: number;

//     // total distance of the survey flight path
//     Distance: number;

//     // Ground Sample Distance that is either calculated or inputted
//     GSD: number;

//     // Flight speed of the drone
//     Speed: number;

//     // Flight speed to change to at last waypoint
//     ExitSpeed: number;

//     // Whether the heading is fixed or follows the flight path.
//     // This is enum type HeadingMode
//     // Using "any" here to appease the compiler gods
//     HeadingMode: any = 'Fixed Heading';

//     // Heading the drone will maintain during the flight if not following the flight path (Copter Only)
//     Heading: number;

//     // Should be zero for all survey/nadir missions
//     CameraAngle: number;

//     // Overlap between shots (assumes landscape picture mode)
//     FrontOverlap: number;

//     // Side overlap which determines the width of the flight lanes
//     SideOverlap: number;

//     // Image area on map represented with closed polygon
//     ImageAreaPolygon: Array<GeoPoint>;

//     // Auto-generated flight path from area and sensor inputs represented as polyline
//     FlightPath: Array<GeoPoint>;

//     // Image capture points along flight path
//     ImageCapturePoints: Array<GeoPoint>;

//     // Total time of the survey flight
//     FlightTime: number;

//     // In square meters
//     SizeOfArea: number;

//     // Height of highest elevation in image area
//     HighElevation: number;

//     // Height of lowest elevation in image are
//     LowElevation: number;

//     // Number of flight lanes in survey command
//     FlightLaneCount: number;

//     // Total number of images for the survey flight
//     ImageCount: number;

//     // Size in MB of storage needed base on number of images time image size from camera
//     ImageStorage: number;

//     //elevationProfile: TerrainProfile;

//     private _data: any = {};

//     hydrate(data: any): void {

//         if (_.isEmpty(data)) {
//             this.handle.off(this.handle.EVENTS.DATA_CHANGED);
//             return;
//         }

//         if (data) {

//             var dataChanged: boolean = false;
//             var triggerRedraw: boolean = false;
//             var imageAreaUpdated: boolean = false;

//             if (this._data.AltGSDMode !== data.AltGSDMode) {
//                 this.AltGSDMode = AltGSDMode[AltGSDMode[data.AltGSDMode]];
//                 dataChanged = true;
//             }

//             if (this._data.Altitude !== data.Altitude) {
//                 this.Altitude = data.Altitude;
//                 dataChanged = true;
//                 triggerRedraw = true;
//             }

//             if (this._data.Distance !== data.Distance) {
//                 this.Distance = data.Distance;
//                 dataChanged = true;
//             }

//             if (this._data.GSD !== data.GSD) {
//                 this.GSD = data.GSD;
//                 dataChanged = true;
//                 triggerRedraw = true;
//             }

//             if (this._data.HeadingMode !== data.HeadingMode) {
//                 this.HeadingMode = HeadingMode[HeadingMode[data.HeadingMode]];
//                 dataChanged = true;
//             }

//             if (this._data.Speed !== data.Speed) {
//                 this.Speed = data.Speed;
//                 dataChanged = true;
//                 triggerRedraw = true;
//             }

//             if (this._data.ExitSpeed !== data.ExitSpeed) {
//                 this.ExitSpeed = data.ExitSpeed;
//                 dataChanged = true;
//             }

//             if (this._data.Heading !== data.Heading) {
//                 this.Heading = data.Heading;
//                 dataChanged = true;
//             }

//             if (this._data.CameraAngle !== data.CameraAngle) {
//                 this.CameraAngle = data.CameraAngle;
//                 dataChanged = true;
//             }

//             if (this._data.FrontOverlap !== data.FrontOverlap) {
//                 this.FrontOverlap = data.FrontOverlap;
//                 dataChanged = true;
//                 triggerRedraw = true;
//             }

//             if (this._data.SideOverlap !== data.SideOverlap) {
//                 this.SideOverlap = data.SideOverlap;
//                 dataChanged = true;
//                 triggerRedraw = true;
//             }

//             if (this._data.FlightLaneCount !== data.FlightLaneCount) {
//                 this.FlightLaneCount = data.FlightLaneCount;
//                 dataChanged = true;
//             }

//             if (this._data.HighElevation !== data.HighElevation) {
//                 this.HighElevation = data.HighElevation;
//                 dataChanged = true;
//             }

//             if (this._data.LowElevation !== data.LowElevation) {
//                 this.LowElevation = data.LowElevation;
//                 dataChanged = true;
//             }

//             if (this._data.FlightTime !== data.FlightTime) {
//                 this.FlightTime = data.FlightTime;
//                 dataChanged = true;
//             }

//             if (this._data.SizeOfArea !== data.SizeOfArea) {
//                 this.SizeOfArea = data.SizeOfArea;
//                 dataChanged = true;
//             }

//             if (this._data.Order !== data.Order) {
//                 this.Order = data.Order;
//                 dataChanged = true;
//             }

//             if (this._data.Name !== data.Name) {
//                 this.Name = data.Name;
//                 dataChanged = true;
//             }

//             if (this._data.Expanded !== data.Expanded) {
//                 this.Expanded = data.Expanded;
//                 dataChanged = true;
//             }

//             if (this._data.ImageAreaPolygon) {
//                 var hasChanged: boolean = false;
//                 // check if image area polygon has changed, if it has then set triggerRedraw to true
//                 this._data.ImageAreaPolygon.forEach((geoPoint: GeoPoint, index: number): void => {
//                     if (!data.ImageAreaPolygon[index] || data.ImageAreaPolygon[index].lat !== geoPoint.lat || data.ImageAreaPolygon[index].lng !== geoPoint.lng) {
//                         hasChanged = true;
//                     }
//                 });

//                 if (hasChanged) {

//                     this.ImageAreaPolygon.splice(0, this.ImageAreaPolygon.length);

//                     for (var i: number = 0, len: number = data.ImageAreaPolygon.length; i < len; i++) {
//                         this.ImageAreaPolygon.push(new GeoPoint(data.ImageAreaPolygon[i].lat, data.ImageAreaPolygon[i].lng));
//                     }

//                     imageAreaUpdated = true;
//                     triggerRedraw = true;
//                 }

//             } else {

//                 // if data has polygon points
//                 if (data.ImageAreaPolygon.length > 0) {

//                     this.ImageAreaPolygon.splice(0, this.ImageAreaPolygon.length);

//                     for (var x: number = 0, lenx: number = data.ImageAreaPolygon.length; x < lenx; x++) {
//                         this.ImageAreaPolygon.push(new GeoPoint(data.ImageAreaPolygon[x].lat, data.ImageAreaPolygon[x].lng));
//                     }

//                     imageAreaUpdated = true;

//                 } else {
//                     this.ImageAreaPolygon = [];
//                 }
//             }

//             this._data = data;

//             if (dataChanged) {
//                 //this.onModelUpdated.trigger('dataChanged');
//             }

//             if (triggerRedraw) {
//                 //this.onModelUpdated.trigger('redrawFlightPath');
//             }

//             if (imageAreaUpdated) {
//                 //this.onImageAreaUpdated.trigger(imageAreaUpdated);
//             }
//         }
//     }

//     SaveProperty(prop: any, propName: string): void {
//         this.handle.setValue(propName, prop)
//             .catch((error: any): void => {
//                 // TODO how should we display error?
//                 console.log(error);
//             });
//     }

//     Update(data: any): void {
//         this.handle.update(data).catch((error: any): void => {
//             console.log(error);
//         });
//     }

//     static defaultData(imageArea: Array<GeoPoint>): any {
//         return {
//             AltGSDMode: 'Altitude',
//             Altitude: 60,
//             Distance: 0,
//             GSD: 1.5,
//             Speed: 5,
//             ExitSpeed: 5,
//             HeadingMode: 'Fixed Heading',
//             Heading: 0,
//             CameraAngle: 0,
//             FrontOverlap: 10,
//             SideOverlap: 10,
//             ImageAreaPolygon: imageArea,
//             Name: 'Survey',
//             Expanded: true,
//             FlightTime: 0,
//             SizeOfArea: 0,
//             HighElevation: 0,
//             LowElevation: 0,
//             FlightLaneCount: 0
//         };
//     }
// }

// export class SurveyCommandView extends SurveyCommand {


//     // Rectangle representing the size and location of the planned image capture points
//     ImageCaptureRects: Array<ImageCaptureRect>;

//     constructor(id?: string, handle?: any) {
//         super(id, handle);
//     }

//     //get ReadableSizeOfArea(): string {
//     //    return DS.Utility.readableArea(this.SizeOfArea, true);
//     //}
//     //
//     //get ReadableDistance(): string {
//     //    return DS.Utility.readableDistance(this.Distance, true);
//     //}
//     //
//     //get ReadableSpeed(): string {
//     //    return DS.Utility.readableSpeed(this.Speed, true);
//     //}
//     //
//     //get ReadableHighElevation(): string {
//     //    return DS.Utility.readableElevation(this.HighElevation, true);
//     //}
//     //
//     //get ReadableLowElevation(): string {
//     //    return DS.Utility.readableElevation(this.LowElevation, true);
//     //}

//     // Photo interval time in seconds
//     get PhotoIntervalTime(): string {
//         return Math.round((this.verticalDistance * (1 - (this.FrontOverlap * .01))) / this.Speed) + ' s';
//     }

//     // Photo interval distance in meters used in flight info
//     get PhotoIntervalDistance(): number {
//         return this.verticalDistance * (1 - (this.FrontOverlap * .01));
//     }

//     // Used in flight info
//     get HorizontalCoverage(): number {
//         return this.calculateHorizontalCoverage();
//     }

//     // Used in flight info
//     get VerticalCoverage(): number {
//         return this.calculateVerticalCoverage();
//     }

//     // Used in flight info
//     get FrontOverlapDistance(): number {
//         return (this.verticalDistance * (this.FrontOverlap * .01));
//     }

//     // Used in flight info
//     get SideOverlapDistance(): number {
//         return (this.horizontalDistance * (this.SideOverlap * .01));
//     }

//     // Horizontal Coverage in Meters
//     // =2*flightAltitude*TAN(RADIANS(horizontalFOV/2))
//     calculateHorizontalCoverage(): number {
//         return (2 * this.Altitude * Math.tan(Conversions.toRadians(this.horizontalFOV() / 2)));
//     }

//     // Vertical Coverage in Meters
//     // =2*flightAltitude*TAN(RADIANS(verticalFOV/2))
//     calculateVerticalCoverage(): number {
//         return (2 * this.Altitude * Math.tan(Conversions.toRadians(this.verticalFOV() / 2)));
//     }

//     get verticalDistance(): number {
//         return this.calculateVerticalCoverage();
//     }

//     get horizontalDistance(): number {
//         return this.calculateHorizontalCoverage();
//     }

//     // GSD should be the same for both horizontal and vertical
//     // Calculates the GSD for the current flight segment and ensures that both horizontal and vertical calculations match before returning
//     // The return value is in centimeters per pixel
//     //private updateGSD(): void {
//     //    var xGSD: number = 100 * (this.calculateHorizontalCoverage() / this._camera.HorizontalResolution);
//     //
//     //    //this.GSD = DS.Utility.roundToTwo(xGSD);
//     //
//     //    var roundedGSD: number = DS.Utility.roundToTwo(xGSD);
//     //
//     //    if (this.GSD !== DS.Utility.roundToTwo(xGSD)) {
//     //        this.SaveProperty(roundedGSD, 'GSD');
//     //    }
//     //}
//     //
//     //private updateAltitude(): void {
//     //    //this.Altitude = ((this._camera.HorizontalResolution * (this.GSD / 100)) * (this._camera.FocalLength / this._camera.SensorWidth));
//     //
//     //    var calculatedAltitude: number = ((this._camera.HorizontalResolution * (this.GSD / 100)) * (this._camera.FocalLength / this._camera.SensorWidth));
//     //
//     //    if (this.Altitude !== calculatedAltitude) {
//     //        this.SaveProperty(calculatedAltitude, 'Altitude');
//     //    }
//     //
//     //}

//     private horizontalFOV(): number {
//         return Conversions.toDegrees((2 * Math.atan(this._camera.SensorWidth / (2 * this._camera.FocalLength))));
//     }

//     // Degrees(2*ATAN(sensorHeight/(2*focalLength)))
//     private verticalFOV(): number {
//         return Conversions.toDegrees((2 * Math.atan(this._camera.SensorHeight / (2 * this._camera.FocalLength))));
//     }

//     //get ReadableGSD(): number {
//     //    return this.GSD;
//     //}
//     //
//     //set ReadableGSD(gsd: number) {
//     //    if (gsd) {
//     //        //this.GSD = gsd;
//     //        this.updateAltitude();
//     //    }
//     //}
//     //
//     //get ReadableAltitude(): number {
//     //    if (this.Altitude > 0) {
//     //        return parseFloat(this.Altitude.toFixed(2));
//     //    } else {
//     //        return 0;
//     //    }
//     //}
//     //
//     //set ReadableAltitude(alt: number) {
//     //    if (alt) {
//     //        //this.Altitude = alt;
//     //
//     //        if (this.Altitude !== alt) {
//     //            this.SaveProperty(alt, 'Altitude');
//     //        }
//     //
//     //        this.updateGSD();
//     //    }
//     //}

// }

// // Represents the location and size of the ground capture point
// export class ImageCaptureRect {

//     // Center coordinate of the rect.
//     CenterPoint: GeoPoint;

//     // Width in meters
//     Width: number;

//     // Height in meters
//     Height: number;
// }
