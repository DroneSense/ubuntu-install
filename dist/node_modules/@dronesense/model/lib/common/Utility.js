"use strict";
var GeoPoint_1 = require('../models/GeoPoint');
var Conversions = (function () {
    function Conversions() {
    }
    Conversions.readableDistance = function (distance, isMetric) {
        var distanceStr;
        if (isMetric) {
            if (distance > 1000) {
                distanceStr = (distance / 1000).toFixed(2) + ' km';
            }
            else {
                distanceStr = distance.toFixed(2) + ' m';
            }
        }
        else {
            distance *= 3.2808;
            if (distance > 5280) {
                distanceStr = (distance / 5280).toFixed(2) + ' miles';
            }
            else {
                distanceStr = Math.ceil(distance) + ' ft';
            }
        }
        return distanceStr;
    };
    Conversions.readableElevation = function (elevation, isMetric) {
        var distanceStr;
        if (isMetric) {
            distanceStr = elevation.toFixed(2) + ' m';
        }
        else {
            elevation *= 3.2808;
            distanceStr = Math.ceil(elevation) + ' ft';
        }
        return distanceStr;
    };
    Conversions.metersToFeet = function (elevation) {
        return Math.ceil(elevation * 3.2808);
    };
    Conversions.feetToMeters = function (elevation) {
        return parseFloat((elevation * 0.3048).toFixed(2));
    };
    Conversions.cmToIn = function (cm) {
        return cm * 0.393701;
    };
    Conversions.inToCM = function (inches) {
        return inches * 2.5400013716;
    };
    Conversions.readableArea = function (area, isMetric) {
        var areaStr;
        if (isMetric) {
            if (area >= 10000) {
                areaStr = (area * 0.0001).toFixed(2) + ' ha';
            }
            else {
                areaStr = area.toFixed(2) + ' m&sup2;';
            }
        }
        else {
            area /= 0.836127;
            if (area >= 3097600) {
                areaStr = (area / 3097600).toFixed(2) + ' mi&sup2;';
            }
            else if (area >= 4840) {
                areaStr = (area / 4840).toFixed(2) + ' acres';
            }
            else {
                areaStr = Math.ceil(area) + ' yd&sup2;';
            }
        }
        return areaStr;
    };
    Conversions.readableSpeed = function (speed, isMetric) {
        var speedStr;
        if (isMetric) {
            speedStr = speed + ' m/s';
        }
        else {
            if (speed === 0) {
                return '0 mph';
            }
            speed = speed * 2.23694;
            speedStr = speed.toFixed(1) + ' mph';
        }
        return speedStr;
    };
    Conversions.geodesicArea = function (latLngs) {
        var pointsCount = latLngs.length, area = 0.0, d2r = Math.PI / 180, p1, p2;
        if (pointsCount > 2) {
            for (var i = 0; i < pointsCount; i++) {
                p1 = latLngs[i];
                p2 = latLngs[(i + 1) % pointsCount];
                area += ((p2.lng - p1.lng) * d2r) *
                    (2 + Math.sin(p1.lat * d2r) + Math.sin(p2.lat * d2r));
            }
            area = area * 6378137.0 * 6378137.0 / 2.0;
        }
        return Math.abs(area);
    };
    Conversions.readableCoordinate = function (coordinate) {
        return coordinate.toFixed(7);
    };
    Conversions.formatCoordinate = function (coordinate, digits) {
        return parseFloat(coordinate.toFixed(digits));
    };
    Conversions.distanceToPoint = function (x1, y1, x2, y2) {
        var xs = 0;
        var ys = 0;
        xs = x2 - x1;
        xs = xs * xs;
        ys = y2 - y1;
        ys = ys * ys;
        return Math.sqrt(xs + ys);
    };
    Conversions.bearingFromCoordinates = function (lat1, long1, lat2, long2) {
        var φ1 = Conversions.toRadians(lat1), φ2 = Conversions.toRadians(lat2);
        var Δλ = Conversions.toRadians(long2 - long1);
        var y = Math.sin(Δλ) * Math.cos(φ2);
        var x = Math.cos(φ1) * Math.sin(φ2) -
            Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
        var θ = Math.atan2(y, x);
        return (Conversions.toDegrees(θ) + 360) % 360;
    };
    Conversions.destinationPoint = function (point, bearing, distance, radius) {
        radius = 6371e3;
        var dis = distance / radius;
        var bear = Conversions.toRadians(bearing);
        var lat1 = Conversions.toRadians(point.lat);
        var lng1 = Conversions.toRadians(point.lng);
        var lat2 = Math.asin(Math.sin(lat1) * Math.cos(dis) + Math.cos(lat1) * Math.sin(dis) * Math.cos(bear));
        var lng2 = lng1 + Math.atan2(Math.sin(bear) * Math.sin(dis) * Math.cos(lat1), Math.cos(dis) - Math.sin(lat1) * Math.sin(lat2));
        lng2 = (lng2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
        return new GeoPoint_1.default(Conversions.toDegrees(lat2), Conversions.toDegrees(lng2));
    };
    Conversions.distanceTo = function (point1, point2) {
        var R = 6378137, d2r = Math.PI / 180, dLat = (point2.lat - point1.lat) * d2r, dLon = (point2.lng - point1.lng) * d2r, lat1 = point1.lat * d2r, lat2 = point2.lat * d2r, sin1 = Math.sin(dLat / 2), sin2 = Math.sin(dLon / 2);
        var a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    };
    Conversions.distance2 = function (lat1, lng1, lat2, lng2) {
        return Conversions.distanceTo(new GeoPoint_1.default(lat1, lng1), new GeoPoint_1.default(lat2, lng2));
    };
    Conversions.toRadians = function (degrees) {
        return degrees * (Math.PI / 180);
    };
    Conversions.toDegrees = function (radians) {
        return radians * 180 / Math.PI;
    };
    Conversions.isOdd = function (num) {
        return (num % 2) === 1;
    };
    Conversions.earthRadius = function () {
        return 40075016.68557849;
    };
    Conversions.calculateHeight = function (xDistance, yDistance, xPixels) {
        return ((yDistance * xPixels) / xDistance);
    };
    Conversions.roundToTwo = function (num) {
        return +num.toFixed(2);
    };
    Conversions.newGuid = function () {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    };
    Conversions.toInchesHG = function (mbPressure) {
        return 0.0295300 * mbPressure;
    };
    Conversions.toMBPressure = function (inHg) {
        return 33.8639 * inHg;
    };
    Conversions.getResolution = function (zoomLevel, latitudeCorrected, latitude) {
        if (latitudeCorrected) {
            return Conversions.earthRadius() * Math.cos(Conversions.toRadians(latitude)) / Math.pow(2, zoomLevel + 8);
        }
        else {
            return Conversions.earthRadius() / 256 / Math.pow(2, zoomLevel);
        }
    };
    Conversions.toLeafletLatLng = function (coordinate) {
        return new GeoPoint_1.default(coordinate.lat, coordinate.lng);
    };
    Conversions.toLeafletLatLngArray = function (geoPoints) {
        var latLngs = [];
        for (var i = 0, len = geoPoints.length; i < len; i++) {
            latLngs.push(new GeoPoint_1.default(geoPoints[i].lat, geoPoints[i].lng));
        }
        return latLngs;
    };
    Conversions.toGeoPointArray = function (latLngs) {
        var geoPoints = [];
        for (var i = 0, len = latLngs.length; i < len; i++) {
            geoPoints.push(new GeoPoint_1.default(latLngs[i].lat, latLngs[i].lng));
        }
        return geoPoints;
    };
    Conversions.getMaxDistance = function (latLngs, takeoff) {
        var max = 0;
        latLngs.forEach(function (latLng) {
            if (max < Conversions.distanceTo(takeoff, latLng)) {
                max = Conversions.distanceTo(takeoff, latLng);
            }
        });
        return max;
    };
    return Conversions;
}());
exports.Conversions = Conversions;
var Sensor = (function () {
    function Sensor() {
    }
    Sensor.horizontalFOV = function (sensorWidth, focalLength) {
        return Conversions.toDegrees((2 * Math.atan(sensorWidth / (2 * focalLength))));
    };
    Sensor.verticalFOV = function (sensorHeight, focalLength) {
        return Conversions.toDegrees((2 * Math.atan(sensorHeight / (2 * focalLength))));
    };
    Sensor.calculateHorizontalCoverage = function (altitude, horizontalFOV) {
        return (2 * altitude * Math.tan(Conversions.toRadians(horizontalFOV / 2)));
    };
    Sensor.calculateVerticalCoverage = function (altitude, verticalFOV) {
        return (2 * altitude * Math.tan(Conversions.toRadians(verticalFOV / 2)));
    };
    return Sensor;
}());
exports.Sensor = Sensor;

//# sourceMappingURL=Utility.js.map
